package iamkeycontroller

import (
	"context"
	"fmt"
	"net/url"

	pipeline "github.com/ccremer/go-command-pipeline"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/errors"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	exoscalesdk "github.com/exoscale/egoscale/v2"
	exoscalev1 "github.com/vshn/provider-exoscale/apis/exoscale/v1"
	"github.com/vshn/provider-exoscale/operator/pipelineutil"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
	controllerruntime "sigs.k8s.io/controller-runtime"
)

// Observe implements managed.ExternalClient.
func (p *IAMKeyPipeline) Observe(ctx context.Context, mg resource.Managed) (managed.ExternalObservation, error) {
	log := controllerruntime.LoggerFrom(ctx)
	log.V(1).Info("Observing resource")

	iamKey := fromManaged(mg)
	if iamKey.Status.AtProvider.KeyID == "" {
		// get the data generated by Create() via annotations, since in Create() we're not allowed to update the status.
		if KeyId, exists := iamKey.Annotations[KeyIDAnnotationKey]; exists {
			iamKey.Status.AtProvider.KeyID = KeyId
			delete(iamKey.Annotations, KeyIDAnnotationKey)
		} else {
			// New resource, create user first
			return managed.ExternalObservation{}, nil
		}
	}

	pctx := &pipelineContext{Context: ctx, iamKey: iamKey}
	err := p.getIAMKey(pctx)
	if err != nil {
		return managed.ExternalObservation{}, resource.Ignore(isNotFound, err)
	}

	pipe := pipeline.NewPipeline[*pipelineContext]()
	result := pipe.WithBeforeHooks(pipelineutil.DebugLogger(pctx)).
		WithSteps(
			pipe.NewStep("fetch credentials secret", p.fetchCredentialsSecret),
			pipe.NewStep("check credentials", p.checkSecret),
		).RunWithContext(pctx)

	if result != nil {
		connDetails, err := toConnectionDetails(pctx.iamExoscaleKey)
		if err != nil {
			return managed.ExternalObservation{}, fmt.Errorf("cannot parse connection details: %w", err)
		}
		return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: false, ConnectionDetails: connDetails}, nil
	}

	iamKey.Status.AtProvider.KeyName = *pctx.iamExoscaleKey.Name
	iamKey.Status.AtProvider.ServicesSpec.SOS.Buckets = getBuckets(*pctx.iamExoscaleKey.Resources)

	iamKey.SetConditions(xpv1.Available())
	connDetails, err := toConnectionDetails(pctx.iamExoscaleKey)
	if err != nil {
		return managed.ExternalObservation{}, fmt.Errorf("cannot parse connection details: %w", err)
	}
	return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: true, ConnectionDetails: connDetails}, nil
}

// getIAMKey fetches an existing IAM key from the project associated with the API Key and Secret.
func (p *IAMKeyPipeline) getIAMKey(ctx *pipelineContext) error {
	log := controllerruntime.LoggerFrom(ctx)

	exoscaleIAMKey, err := p.exoscaleClient.GetIAMAccessKey(ctx, ctx.iamKey.Spec.ForProvider.Zone, ctx.iamKey.Status.AtProvider.KeyID)
	if err != nil {
		return err
	}
	ctx.iamExoscaleKey = exoscaleIAMKey
	log.V(1).Info("Fetched IAM key in exoscale", "iamID", exoscaleIAMKey.Key, "keyName", exoscaleIAMKey.Name)
	return nil

}

func (p *IAMKeyPipeline) fetchCredentialsSecret(ctx *pipelineContext) error {
	secretRef := ctx.iamKey.Spec.WriteConnectionSecretToReference
	ctx.credentialsSecret = &corev1.Secret{}
	return p.kube.Get(ctx, types.NamespacedName{Namespace: secretRef.Namespace, Name: secretRef.Name}, ctx.credentialsSecret)

}

func (p *IAMKeyPipeline) checkSecret(ctx *pipelineContext) error {
	data := ctx.credentialsSecret.Data

	if len(data) == 0 {
		return fmt.Errorf("secret %q does not have any data", fmt.Sprintf("%s/%s", ctx.credentialsSecret.Namespace, ctx.credentialsSecret.Name))
	}

	// Populate secret key from the secret credentials as exoscale IAM get operation does not return the secret key
	secret := string(data[exoscalev1.SecretAccessKeyName])
	ctx.iamExoscaleKey.Secret = &secret
	return nil
}

func getBuckets(iamResources []exoscalesdk.IAMAccessKeyResource) []string {
	buckets := make([]string, 0, len(iamResources))
	if len(iamResources) == 0 {
		return buckets
	}
	for _, iamResource := range iamResources {
		if iamResource.Domain == SOSResourceDomain {
			buckets = append(buckets, iamResource.ResourceName)
		}
	}
	return buckets
}

func isNotFound(err error) bool {
	var errResp *url.Error
	if errors.As(err, &errResp) {
		return err.(*url.Error).Err.Error() == "resource not found"
	}
	return false
}
